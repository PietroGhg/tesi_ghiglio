Links:
a)https://www.embedded.com/energy-efficient-c-code-for-arm-devices/
b)https://www.microcontrollertips.com/writing-efficient-c-code-embedded-systems-cost-unnatural-data-sizes/
c)https://www.microcontrollertips.com/faq-optimizing-power-efficiency-microcontrollers/
d)https://barrgroup.com/embedded-systems/how-to/low-power-management
Michael Keating Davidd Flynn et. al.,”Low Power Methodology Manual”, ARM&Synopsis, 2007




1.
General lack of tools (both static analysis and profiling) for energy usage estimation.
If there where tools, people would use them.
Most of the interest in the mobile app development field.

Embedded systems have few requirements for energy usage:
"For the embedded group, we found several reasons why practitioners do not have requirements or goals about energy usage. First, many embedded products are not battery-powered (e.g., “In our embedded systems, we always have access to power so energy is not a concern.”). Second, many practitioners are concerned with the overall energy usage of their systems but rely on the hardware, not the software, to reduce energy usage. Finally, satisfying other metrics is more important than reducing enery usage (e.g., “Ensuring the deterministic, real-time behaviour of our embedded device is more important than saving energy.”)."

L. Ardito and M. Morisio. Green it-available data and guidelines for reducing energy consumption in it systems. Sustainable Computing: Informatics and Systems

D. Li, S. Hao, W. G. J. Halfond, and R. Govindan. Calculating source line level energy information for Android applications.

N. Ayewah, D. Hovemeyer, J. Morgenthaler, J. Penix, and W. Pugh. Using static analysis to find bugs. IEEE Software, 25(5):22–29, 2008.

B. Johnson, Y. Song, E. Murphy-Hill, and R. Bowdidge. Why don’t software developers use static analysis tools to find bugs? In Proceedings of the International Conference on Software Engineering.

C. Pang, A. Hindle, B. Adams, and A. Hassan. What do programmers know about software energy consumption? Software, IEEE, 2015.

M. Schirmer, S. Bertel, and J. Penke. Contexto: Leveraging energy awareness in the development of context-aware applications. In 4th Workshop on Energy Aware Software-Engineering and Development, pages 131–140,2014.


2.
Four techniques for energy saving:
-Dynamic voltage and frequency scaling
-Low power modes
-Microarchitectural techniques (eg memory hierarchy)
-Using GPUs, FPGAs


3.
List of 25 "rules" for energy efficient code.
Shows that doing these optimizations by hand is better than automatically by the compiler.
These techniques are probably designed to optimize execution time.


4.
Profile in order to understand core sets of instructions.
Three types of optimizations:
-Algorithmic (depend on the task)
-Data (depend on architecture)
-Instruction flow (general techniques like loop unrolling. inline assembly)

https://ieeexplore.ieee.org/abstract/document/6530444
https://ieeexplore.ieee.org/abstract/document/4488783

4.1
9 techniques for avoiding "energy code smells", < 1% efficiency.
Citato da articoli interessanti.

https://www.sciencedirect.com/science/article/pii/S0164121216000893
https://link.springer.com/article/10.1007/s10586-016-0691-5

4.2 / 4.3
stathistical method to evaluate impact of optimizations. loop unrolling, function inlining, variable declarations.

5.
Paper about Java. Refactoring have impact on energy usage, but the impacts are often inconstitent arcoss different applications. Time != energy in general. stathistical methods.

6.
-Compiler optimizations: most of them increase power but reduce overral energy
-Source to source: loop peeling
	   	   array declaration sorting
		   function inlining
		   figure 4.9, several optimizations


7.
Energy = time*power. Time influences more. Average higher power consuptions doesn't imply higher energy consumption: execution time is reduced.

4.1.1
Overall guidilines for green software development. Check peripherals (GPS, WiFi, Bluetooth, ...). Reduce amount of data transfered (metric: communication energy cost)

link a
arm architecture
-optimize for speed (unless some cases (?) in which small sized code optimizes cache usage)
-match data type and size: 32 bit arch -> 32 bit data
-making lenght of each element in array a power of 2 simplifies offset calculations
-alignment restrictions in passing double words parameters:
	   fx(int a, double b, int c) //a:r0, b:r2r3, c: stack. double words must be in even-odd register pair
	   fx(int a, int c, double b) //a:r0, c:r1, b:r2r3.
-compiler directives:
	  __pure (pure function)
	  __restrict (no write through this pointer changes the value of an item referenced by any other pointer)
	  __promise a given predicate will br true at this point of execution