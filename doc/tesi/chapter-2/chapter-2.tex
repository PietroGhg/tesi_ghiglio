\section{Overview}

This section will provide an overview of the state of the art methods to measure, estimate and visualize the energy consumption of software. \par
In general, there is no unique solution to this problem: the proposed techniques vary by both the applicative domain, the properties of the result and the procedure with which the result is obtained. \par
For the applicative domains, we have identified three main cases:
\begin{itemize}
\item Embedded systems: embedded systems are often employed as sensors in contexts where the only source of electricity is their own battery. Therefore, energy consumption has always been a concern of both hardware and software developers.
\item Smart phones: similarly to embedded systems, smart phones have to relay on their own battery to operate. The current rate of battery improvement is around 5\% a year, but the workloads that smart phones have to withstand increases by an order of magnitude every 5 years \cite{nunez}. This means that energy consumption has to be tackled also from the software prospective.
\item Multicore CPU: energy consumption is not a big concern from the point of view of PC users. But it is a primary concern in large datacenters where heat dissipation requires good engineering solutions, and whose impact on global CO2 emission and energy consumption is non-negligible.
\end{itemize}
\par In terms of the properties of the result of the measurement/estimate, solutions differ by their granularity: some provide a single quantity (the total amount of energy consumed by a program), other have a finer grain, allowing to attribute energy measures to either source code entities or hardware components. 
\par The procedure adopted to obtain the result are widely different, \cite{rieger} provides an overview of some techniques, and groups them in simulation-based and measurement-based. Simulation based technique require a model of the target architecture, and, provided a segment of binary code, perform a cycle-accurate simulation of the events that occur during the program's run. \newline
Measurement-based techniques, instead, can be further sub-grouped in roughly three categories:
\begin{itemize}
\item Direct measurement: the measure can be taken by plugging the device to an instrument that allows to measure the current, voltage or power absorbed by the device while running the program.
\item Performance-counter based: some hardware architectures provide special register that store information about the energy consumption, and a set of APIs that allow to read their contents.
\item Modeling based: some solutions propose to model mathematically the energy behavior of the target architecture, perform some experiments in order to estimate the parameters of the model, and use the model in order to obtain an estimate of the consumed energy.
\end{itemize} 
\par The dimensions that we have indicated are not completely orthogonal. In particular, modeling based approaches usually target embedded devices, since they have usually simpler underlying architectures that are inherently simpler to analyze. \newline Performance counter based method, instead, are bound to specific architectures that provide such counters, such as Intel's Running Average Power Limit (RAPL), for their Sandy Bridge architectures, the Intel System Management Controller (SMC) for the Xeon Phi, or NVidia's Nvidia Management Library (NVML), that allows to obatin energy consumption of their GPUs.

\section{Instruction Level Energy modeling}
Given a target's Instruction Set Architecture (ISA), an energy model is a model of the energy consumed by each instruction.
They have been introduced in 1996 by Tiwari et al. \cite{tiwari}. 
\subsection{Characterization of an ISA Energy model}
The main components of an energy model are:
\begin{itemize}
\item Instruction base cost ($B_{i}$, for each instruction $i$): the cost associated with the basic processing needed to execute an instruction. 
\item Effect of circuit state ($O_{i,j}$, for each pair of instruction $i$, $j$): the cost of the switching activity resulting from executing two consecutive instructions differing one from another.
\item Other inter-instruction effects ($E_{k}$, for each additional effect $k$): any other effect that can occur in real program, such as stalls or cache misses.
\end{itemize}
\par Given these components and a program $P$, the total energy consumed by it, $E_{p}$, is given by:
\begin{gather*}
E_{p} = \sum_{i} (B_{i} \times N_{i}) + \sum_{i,j} (O_{i,j} \times N_{i,j}) + \sum_{k} E_{k}
\end{gather*}
Where $N_{i}$ is the number of occurrences of instruction $i$, and $N_{i,j}$ is the number of times there has been a switch from instruction $i$ to instruction $j$.

\subsection{Why employing an ISA energy model}
The most common way to describe a processor's power consumption is through the average power consumption. \par
This single number may not provide enough information to characterize the energy consumed by a program running on the target processor: different programs may employ the functional units of the CPU in different ways, leading to different measurements at equal running time. \par
ISA Energy Models offer a more detailed view of the energy profile of the target architecture. They therefore allow to identify variations of consumed energy from one program to another, and may also guide decision of both humans (hardware/software design) and software (compilers or operating systems).

\subsection{Producing an ISA energy model}
Energy models can be produced through an experimental procedure. \newline
In order to obtain instruction base costs, a program consisting of a large loop of a repeated instruction is written. Then one can measure the average current drawn by the processor while executing the program, $\hat{i}$, and multiply it by the supply voltage $V_{cc}$, obtaining the base energy consumption. \newline
Instruction may also be grouped together, since instruction with similar functionality will have similar base cost.\par 
In order to obtain the circuit state effects, loop of pairs of instruction are required. The difference between the instruction's base costs and the average current measured provides the circuit state overhead. \par 
A similar approach can be employed to obtain the costs of other inter-instruction effects: writing large loops in which the examined effect occurs several times, measuring the average current and subtracting the costs that are already known (base costs and circuit state). \par 
The main disadvantage of this approach is that several different programs must be written: for an ISA with $n$ instructions, $\bigO(n)$ programs are required to produce base costs and $\bigO(n^{2})$ for circuit state effects. \newline
Estimation of other inter-instruction effects also gets more difficult as the complexity of the architecture increases. \par
On the other hand, this approach has the big advantage of not requiring a model of the circuit of the target processor, information that is often not disclosed by the manufacturing companies.

 M. T.-C. Lee, V. Tiwari, S. Malik, and M. Fujita.
Power analysis and minimization techniques for
embedded DSP software 
technique to group instructions into common classes.

\section{Energy consumption estimation}
fahad: comparative study of direct measure vs rapl and direct measure vs prediction based on performance counters for intel multicore cpus.
use direct measure as ground truth, it shows that both techniques have very high error.

wattch: architectural simulator that estimates CPU power consumption.
it provides cycle-level power simulation, which allows to compute maximum and average power consumption, and overall energy consumption.
parametrizable power model + resource usage counts obtained through cycle-level simulation. more high level than verilog (less accurate, but doesn't require full circuit design and is way faster). uses simplescalar as architectural simulator, providing it power models of the most common structures present in superscalar microprocessors.
it requires power models of the subcomponents of a processor, such as register files, caches, functional units, reservation stations.
 
Paper eder. 
da leggere less is more\\
xmos energy model: energy modeling of multi-threaded architecture. context switching has an energy cost. extends tiwari's model by adding thread switching cost. xmprofile software suite: allows to generate load and monitor test executions. tests are generated automatically. generate tests only for instructions with no effects on control flow and no non-deterministic timing.
observes that number of operands has significant impact on power consumption. data width has an impact on power consumption (low impact). they choose to generalize inter-instruction overhead. 
for instructions that cannot be directly tested, they propose two solutions: 1) group instructions by number of operands, and put the untestable instr in the appropriate group. 2) assign default cost to untestable instr. 
they obtain execution statistics by hardware simulation (this can be replaced by profiling).
grouped model performs worse than individual model (16percent error vs 7percent error). both provide a consistent underestimation.


lee: energy model of risc architectures, targeting embedded systems. combining empirical method and statistical analysis.
developed a model whose unknown are estimated tanks to data from empirical observations, through linear regression. they say that modeling in tiwari's way is too simplistic, since it relays only on average current.  
First they model the energy consumption: pipelined processor, e(X,Y) is the energy when X is executed after Y (this allows to consider switching activity). it depends on several variables (v), they consider f(vx,vy): the variation on the variable v between x and y, which depends on the hemming distance between vx and vy. 
they test several sets of programs: in the first set, they test same instructions, same operands different location and determine the impact of the instruction fetch stage. in the second set, they derive instruction base cost in each of the pipeline stages.

nunez-yanez: system level energy/power modeling (on chip system: memory, cpu, gpu; no camera/display). they require RTL design information (often not available), and then through linear regression they produce a power model of the whole SoC. They provide high detail, being able to characterize power consumption of different components (cpu, ram, cache), but the requirement of the RTL design is too strict. 

brandolese2008: energy estimation from source code and visualization on source code. the parse tree of a C program is decorated by associating a a cost-contribution (atom) to each node. following the grammar's rule of the C language, rules to combine instruction costs are defined. the parse tree is then instrumented in order to produce a trace during the program's execution. cost coefficients are estimated through least square fitting, comparing to to the output of the ARMulator instruction set simulator.
this approach relays on analyzing the parse tree. this allows source code visualization but binds to the source level language: in order to change source language, it would be required to perform a complete analysis of the grammar rule of the new language.
claims to be 10k times faster than ARMulator.

rieger: misurazione diretta della corrente (campo magnetico indotto) + metodo preso da NLP. dicono loro stessi che non funziona. \\
rieger-survey: alcuni tool commericali, altra letteratura. molto android/java (ex. powertutor)
roth: piattaforma hardware per creare energy models + xml dell'energy model per intergrarlo nel loro compilatore, il quale fornisce una stima worst case. \\
brandolese: \\  come eder è llvm-based, differiscono per ir-assembly mapping. eder ha anche metodo statico-worst case. \\
pereira: source level view, statistical method to provide ranking, no energy estimation, just visualization. \\
jrapl. only intel, code segment granularity. check intel rapl 


