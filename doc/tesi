backgroud:
	llvm
		definition
		ir
		ssa
		important classes
		metadata
		passes
	debug info
	dwarf format
	energy modeling
	       definition
	       use cases

state of the art:
      how llvm handles debug information
      	  guidelines
      visualization of compiler optimizations
      		    opt functionalities
      how to produce an energy model
      	  hw simulation
	  measurment
      eder's paper



The LLVM Project is a collection of modular and reusable compiler toolchain technologies. It is built around an intermediated representation called LLVM-IR, and provides a set of APIs to interact with it. LLVM provides an optimizer that works on the intermediate representation, and also several code generation helpers that allow to target all the main hardware architectures.

IR
The LLVM-IR is a language that resembles a generic assembly language, while also providing some high level features such as unlimited registers, explicit stack memory allocation and pointer deferentation.
This allows LLVM-IR to be both the ideal target for high-level language developers, that do not have to worry about architecture specific details, and also the ideal source language for compiler back-end developers, that have to implement only a translator from LLVM-IR to their target architecture's assembly language, without worrying about high-level language features.
The LLVM-IR is accesible in three formats: in-memory represantation, that allows manipulation through the LLVM APIs, binary format, used by many LLVM tools, and the human-readable textual format, that can also very conveniently be parsed by means of the APIs.

SSA and PHI-Nodes
The LLVM-IR is by definition in SSA (Static Single Assignment) form. The SSA form requires a variable to be assigned only once, and requires every variable to be defined before its uses. It is called static because it does not take into account dynamic (related to the program's runtime) consideration: an assignment in a loop counts always as one assignment, even if at runtime it will be performed several times.
----esempio
It is always clear which definition to use, unless a basic block has multiple predecessors. In that case it is necessary to add phi nodes that carry the informations to disambiguate the uses at runtime.
----esempio

LLVM Class hierarchy
The class hierarchy defined in the LLVM APIs consists of hundreds of classes, a complete and exaustive view is given by the LLVM Doxygen Documentation. The main components of the hierarchy are:
- Module: the entire program/compile unit. Contains the globals of the program: mainly the global variables and the functions.
- Function: a function in the compile unit, contains mainly a set of arguments and it's control flow graph in the form of a set of basic blocks.
- Basic Block: a set of instructions with no branches between them.
- Instruction: An instruction of the IR.
Another key class in the LLVM class hierarchy is the Value class. It represents anything that has a type and can be used as an operand to an instruction: function arguments, constants, instructions, basic blocks and functions are all Values.
A Value also carries information of what other Values it uses, and what other Values use it.

LLVM Metadata
LLVM IR allows metadata to be attached to instructions in the program that can convey extra information about the code to the optimizers and code generator.
The main use of metadata is debug information, but they may also carry information about loop boundaries or other assumption that are usefull during the optimization or code generation phase. Metadata can either be a simple string attached to an instruction, or they can be a Metadata Node (MDNode). MDNodes can reference each other and are specified by other classes in the LLVM APIs. See section blabla or the LLVM Language Reference for further informations.

LLVM Passes
LLVM passes are where most of the interesting parts of the compiler exist. Passes perform the transformations and optimizations that make up the compiler, they build the analysis results that are used by these transformations, and they are, above all, a structuring technique for compiler code.
In LLVM, passes may depend on other passes, for instance a pass that performs an optimization may require the results of a pass that performs a specific analysis.
They are therefore handled by a Pass Manager, that schedules the passes, ensuring that all the requirements for a pass are satisfied before executing it.

Debug informations
A debugger is a computer program used to test and debug other programs. It allows a programmer to run the target program in controlled conditions, pause the program's execution, check the state of variables and more.
The main functionalities of a debugger, over which more advanced features can be built, are setting break points and accessing the content of a variable.
A compiler will store informations to allow this operations in the programs's executable, the format used to do so may vary with the compiler/operating system used, but the stored informations are:
- Definition of the data types employed in the program.
- Mapping between variables defined in the source code and memory location in which they are stored.
- Mapping between source code locations and assembly instruction.

The DWARF format
DWARF is a debugging data format that allows source-level debugging, is was originally designed together with the ELF executable format. 
      
      